'use strict';

import builder from 'botbuilder';
import BotUtils from './bot-utils';
import url from 'url';
import fileType from 'file-type';
import async from 'async';
import request from 'request';
import uuid from 'node-uuid';
import fs from 'fs';
import winston from 'winston';
import _ from 'lodash';

/**
 * Static class for the Bot Base Actions.
 * This class describes the default actions, and the acelerators that
 * return cards that are converted to actions by the bot core.
 */
class BaseActions {

  /**
   * Creates a card that triggers a begin dialog action.
   *
   * @param { String } path Path of the dialog to be started.
   * @returns { Object } Card that triggers a begin dialog action.
   */
  static beginDialog(path) {
    return {
      type: 'action',
      subtype: 'begin',
      path: path
    };
  }

  /**
   * Creates a card that triggers an end dialog action.
   *
   * @returns { Object } Card that triggers an end dialog action.
   */
  static endDialog() {
    return {
      type: 'action',
      subtype: 'end'
    };
  }

  /**
   * Creates a card that triggers a send list action.
   *
   * @param { Array } cards Array of cards to be included into the list.
   * @returns { Object } Card that triggers a send list action.
   */
  static sendList(cards) {
    return {
      type: 'action',
      subtype: 'sendList',
      cards: cards
    };
  }

  /**
   * Creates a card that triggers a send carousel action.
   *
   * @param { Array } cards Array of cards to be included into the carousel.
   * @returns { Object } Card that triggers a send carousel action.
   */
  static sendCarousel(cards) {
    return {
      type: 'action',
      subtype: 'sendCarousel',
      cards: cards
    };
  }

  /**
   * Base action for sending a card or an array of cards.
   * It automatically calculates if the next() must be called, based on the
   * type of the cards (identify if it's a prompt or not).
   *
   * @param { Array } cards Array of cards, or one card, to be sent.
   * @param { Object } session Chat session.
   * @param { Object } args Arguments of the chat session.
   * @param { Function } next Bot next callback function.
   */
  static sendAction(cards, session, args, next) {
    winston.log('debug', 'Send Action');
    cards = BotUtils.ensureArray(cards);
    var countPrompt = 0;
    var countChoice = 0;
    cards.forEach(function(card) {
      if (card.type === 'choice') {
        countChoice++;
      } else if (card.type === 'prompt') {
        countPrompt++;
      }
    });
    this.send(session, cards, function(error, dataSent) {
      if (error) {
        winston.log('error', error);
      }
      if (countPrompt === 0 && countChoice === 0) {
        next();
      }
    });
  }

  /**
   * Given a list of cards, iterates every one. If the card is an string,
   * it means that is the name of the card, stored in the core, so retrieve
   * the object given the name.
   *
   * @param { Array } cards Array of cards to be built.
   */
  static buildCardList(cards) {
    var result = [];
    cards = BotUtils.ensureArray(cards);
    for (var i = 0; i < cards.length; i++) {
      if (_.isString(cards[i])) {
        result.push(this.getCard(cards[i]));
      } else {
        result.push(cards[i]);
      }
    }
    return result;
  }

  /**
   * Base action for sending a list of cards.
   *
   * @param { Array } cards Array of cards to be sent.
   * @param { Object } session Chat session.
   * @param { Object } args Arguments of the chat session.
   * @param { Function } next Bot next callback function.
   */
  static sendListAction(cards, session, arg, next) {
    winston.log('debug', 'Send List Action');
    cards = BaseActions.buildCardList(cards);
    var card = {
      type: 'list',
      cards: cards
    };
    this.send(session, [card], function(error, dataSent) {
      if (error) {
        winston.log('error', error);
      }
      next();
    });
  }

  /**
   * Base action for sending a carousel of cards.
   *
   * @param { Array } cards Array of cards to be sent.
   * @param { Object } session Chat session.
   * @param { Object } args Arguments of the chat session.
   * @param { Function } next Bot next callback function.
   */
  static sendCarouselAction(cards, session, args, next) {
    winston.log('debug', 'Send Carousel Action');
    cards = BaseActions.buildCardList(cards);
    var card = {
      type: 'carousel',
      cards: cards
    };
    this.send(session, [card], function(error, dataSent) {
      if (error) {
        winston.log('error', error);
      }
      next();
    });
  }

  /**
   * Base action for begining a dialog.
   *
   * @param { String } path Path of the dialog.
   * @param { Object } session Chat session.
   * @param { Object } args Arguments of the chat session.
   * @param { Function } next Bot next callback function.
   */
  static beginDialogAction(path, session, args, next) {
    winston.log('debug', 'Begin Dialog Action: ' + path);
    session.beginDialog(path);
  }

  /**
   * Base action for ending a dialog.
   *
   * @param { Object } session Chat session.
   * @param { Object } args Arguments of the chat session.
   * @param { Function } next Bot next callback function.
   */
  static endDialogAction(session, args, next) {
    winston.log('debug', 'End Dialog Action');
    session.endDialog();
  }

  /**
   * Base action for replacing a dialog.
   *
   * @param { String } path Path of the dialog.
   * @param { Object } session Chat session.
   * @param { Object } args Arguments of the chat session.
   * @param { Function } next Bot next callback function.
   */
  static replaceDialogAction(path, session, args, next) {
    winston.log('debug', 'Replace Dialog Action: ' + path);
    session.replaceDialog(path);
  }

  /**
   * React to a choice that is a menu. It means that the tag of the
   * choice is the path to the dialog that should be started. If the
   * tag is 'quit' then the current dialog must be ended.
   *
   * @param { Object } session Chat session.
   * @param { Object } args Arguments of the chat session.
   * @param { Function } next Bot next callback function.
   */
  static reactMenuAction(session, args, next) {
    winston.log('debug', 'React Menu Action');
    var tag = this.getSelectedChoice(session, args);
    winston.log('debug', 'Selected choice is: ' + tag);
    if (!tag) {
      this.send(session, [{
        type: 'text',
        text: 'Invalid option. Please select a valid one'
      }], function(error, dataSent) {
        return;
      });
    }
    if (tag === 'quit') {
      session.endDialog();
      return;
    }
    session.beginDialog('/' + tag);
  }

  /**
   * React to a prompt. When the card is a prompt, we are waiting fotr the
   * input of the user. This action takes the input and save it to the variable
   * specified by the card.
   *
   * @param { Object } session Chat session.
   * @param { Object } args Arguments of the chat session.
   * @param { Function } next Bot next callback function.
   */
  static reactPromptAction(session, args, next) {
    winston.log('debug', 'React Prompt Action');
    this.getPromptResponse(session, args, error => {
      error && winston.log('error', error);
      next();
    });
  }

  /**
   * React to a choice prompt. The difference between this an another prompts,
   * is that the choice sends a text that is the visible one to the user
   * (example: label of the button) but this text must be translated into
   * its equivalent tag. This is done inside this method, so the response
   * saved is the tag and not the text of the choice option. This is mandatory,
   * because multilanguage cards can have different text
   *
   * @param { Object } session Chat session.
   * @param { Object } args Arguments of the chat session.
   * @param { Function } next Bot next callback function.
   */
  static reactChoiceAction(session, args, next) {
    winston.log('debug', 'React Choice Action');
    var tag = this.getSelectedChoice(session, args);
    winston.log('debug', 'Selected choice is: ' + tag);
    this.getChoiceResponse(session, args, error => {
      error && winston.log('error', error);
      next();
    });
  }

  /**
   * Method to download an attachment or list of attachments from the message,
   * and save them to a buffer array.
   *
   * @param { Object } connector Bot connector.
   * @param { Object } message Received message with attachments.
   * @param { Function } callback Callback function to be invoked with the
   *        buffers.
   */
  static downloadAttachments(connector, message, callback) {
    winston.log('debug', 'Download attachments');
    var attachments = [];
    var containsSkypeUrl = false;
    message.attachments.forEach(function(attachment) {
      if (attachment.contentUrl) {
        attachments.push({
          contentType: attachment.contentType,
          contentUrl: attachment.contentUrl
        });
        if (url.parse(attachment.contentUrl).hostname
            .substr(-'skype.com'.length) === 'skype.com') {
          containsSkypeUrl = true;
        }
      }
    });
    if (attachments.length > 0) {
      async.waterfall([
        function(cb) {
          if (containsSkypeUrl) {
            connector.getAccessToken(cb);
          } else {
            cb(null, null);
          }
        }
      ], function(err, token) {
        if (!err) {
          var buffers = [];
          async.forEachOf(attachments, function(item, idx, cb) {
            var contentUrl = item.contentUrl;
            var headers = {};
            if (url.parse(contentUrl).hostname
                .substr(-'skype.com'.length) === 'skype.com') {
              headers['Authorization'] = 'Bearer ' + token;
              headers['Content-Type'] = 'application/octet-stream';
            } else {
              headers['Content-Type'] = item.contentType;
            }
            request({
              url: contentUrl,
              headers: headers,
              encoding: null
            }, function(err, res, body) {
              if (!err && res.statusCode === 200) {
                buffers.push(body);
              }
              cb(err);
            });
          }, function(err) {
            if (callback)
              callback(err, buffers);
          });
        } else {
          if (callback) {
            callback(err, null);
          }
        }
      });
    } else {
      if (callback)
        callback(null, null);
    }
  }

  /**
   * Method to react to a prompt when the prompt type is attachment.
   * This method donwloads the attachments and save them into disk, generating
   * a url unique for each attachment using uuid.
   *
   * @param { Object } session Chat session.
   * @param { Object } args Message arguments.
   * @param { Function } next Callback function.
   */
  static reactPromptAttachmentAction(session, args, next) {
    winston.log('debug', 'React Prompt Attachment Action');
    BaseActions.downloadAttachments(this.connector,
      {attachments: args.response}, function(error, buffers) {
        var msg = new builder.Message(session)
          .ntext('I got %d attachment.', 'I got %d attachments.',
            args.response.length);

        if (error) {
          winston.log('error', 'error retrieving attachments ' + error);
        }
        winston.log('debug', 'total buffers: ' + buffers.length);
        for (var i = 0; i < buffers.length; i++) {
          var type = fileType(buffers[i]);
          var filename = uuid.v4() + '.' + type.ext;
          winston.log('debug', 'Attachment File name: ' + filename);
          var wstream = fs.createWriteStream('./client/images/' + filename);
          wstream.write(buffers[i]);
          wstream.end();
          var attach = {
            contentType: type.mime,
            contentUrl: this.domain.getRootVariable('url') +
            '/images/' + filename
          };
          session.dialogData.lastAttachmentUrl =
            this.domain.getRootVariable('url') +
            '/images/' + filename;
          msg.addAttachment(attach);
        }
        next();
      }.bind(this));
  }
}

export default BaseActions;
