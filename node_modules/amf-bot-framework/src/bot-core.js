'use strict';

import async from 'async';
import builder from 'botbuilder';
import fs from 'fs';
import glob from 'glob';
import Handlebars from 'handlebars';
import i18next from 'i18next';
import Backend from 'i18next-node-fs-backend';
import _ from 'lodash';
import path from 'path';
import winston from 'winston';

import BotDomain from './bot-domain';
import BotRenderFactory from './bot-render-factory';
import BaseActions from './bot-base-actions';
import BotMemoryPersistance from './bot-memory-persistance';
import LoopbackPersistance from '../plugins/bot-loopback-persistance';
import RestConnector from './connectors/rest-connector';

class BotCore {

  /**
   * Core for a bot with a variable and template system.
   *
   * @constructor
   * @param { Object } opts Options instance.
   */
  constructor(opts = {}) {
    winston.log('info', 'Creating bot instance');
    this.opts = opts;
    winston.level = opts.loglevel || 'error';

    this.createPersistance(opts);
    this.createConnector(opts);
    this.createBot(opts);
    this.createDomain(opts);
    this.createRenderFactory(opts);

    this.cards = {};
    this.actions = {};
    this.dialogs = {};
    this.observers = {
      conversationUpdate: [],
      contactRelationUpdate: [],
      deleteUserData: [],
      message: [],
      ping: [],
      typing: [],
      personEnterGroup: [],
      personLeaveGroup: []
    };

    this.createCards(opts, () => {
      this.createActions(opts, () => {
        this.createDialogs(opts, () => {
          this.createDialogClass(opts, () => {
            this.configureLocalization(opts);
          });
        });
      });
    });
  }

  /**
   * Assign the persistance. If no persistance is provided, then creates a new
   * in memory persistance.
   *
   * @param { Object } opts Options instance.
   */
  createPersistance(opts) {
    winston.log('info', 'Creating Persistance');
    if (opts.useLoopback && opts.useLoopback === true) {
      winston.log('info', 'Loopback persistance selected');
      this.persistance = new LoopbackPersistance(opts.app);
    } else {
      winston.log('info', 'Custom persistance selected');
      this.persistance = opts.persistance ? opts.persistance : new BotMemoryPersistance();
    }
  }

  /**
   * Creates the chat connector of the bot.
   *
   * @param { Object } opts Options instance.
   */
  createConnector(opts) {
    winston.log('info', 'Creating Connector');
    if (opts.connector) {
      winston.log('info', 'Using custom connector.');
      this.connector = opts.connector;
    } else {
      if (opts.useRest === true) {
        winston.log('info', 'Using REST connector');
        this.connector = new RestConnector(opts);
      } else {
        winston.log('info', 'Using Microsoft ChatConnector.');
        const appId = opts.botAppId || process.env.BOT_APP_ID;
        const appPassword = opts.botAppPassword || process.env.BOT_APP_PASSWORD;
        this.connector = new builder.ChatConnector({appId, appPassword});
      }
    }
  }

  /**
   * Creates the bot based on the connector.
   *
   * @param { Object } opts Options instance.
   */
  createBot(opts) {
    winston.log('info', 'Creating Bot instance.');
    this.bot = new builder.UniversalBot(this.connector, opts.settings);
    this.createBotHooks(opts);
    opts.luisUrl = opts.luisUrl || process.env.LUIS_URL;
    opts.luisAppId = opts.luisAppId || process.env.LUIS_APP_ID;
    opts.luisSubscriptionKey = opts.luisSubscriptionKey ||
      process.env.LUIS_SUBSCRIPTION_KEY;
    if (opts.luisUrl || (opts.luisAppId && opts.luisSubscriptionKey)) {
      winston.log('info', 'Using a LUIS recognizer');
      if (!opts.luisUrl) {
        opts.luisUrl = 'https://api.projectoxford.ai/luis/v1/application?';
        opts.luisUrl += 'id=' + opts.luisAppId;
        opts.luisUrl += '&subscription-key=' + opts.luisSubscriptionKey;
      }
      this.luisrecognizer = new builder.LuisRecognizer(opts.luisUrl);
      this.luisdialog = new builder.IntentDialog({
        recognizers: [this.luisrecognizer]
      });
    } else {
      winston.log('info', 'LUIS recognizer not defined.');
      this.luisrecognizer = null;
      this.luisdialog = null;
    }
  }

  /**
   * Create the hooks for the bot events.
   *
   * @param { Object } opts Options instance.
   */
  createBotHooks(opts) {
    winston.log('info', 'Creating Bot Hooks.');
    let i, j;
    this.bot.on('conversationUpdate', function(message) {
      for (i = 0; i < this.observers.typing.length; i++) {
        this.observers.conversationUpdate[i](message);
      }
      if (message.address.conversation.isGroup) {
        if (message.membersAdded) {
          for (j = 0; j < message.membersAdded.length; j++) {
            for (i = 0; i < this.observers.personEnterGroup.length; i++) {
              this.observers.personEnterGroup[i](message,
                message.membersAdded[j]);
            }
          }
        }
        if (message.membersRemoved) {
          for (j = 0; j < message.membersRemoved.length; j++) {
            for (i = 0; i < this.observers.personLeaveGroup.length; i++) {
              this.observers.personLeaveGroup[i](message,
                message.membersRemoved[j]);
            }
          }
        }
      }
    }.bind(this));
    this.bot.on('contactRelationUpdate', function(message) {
      for (i = 0; i < this.observers.typing.length; i++) {
        this.observers.contactRelationUpdate[i](message);
      }
    }.bind(this));
    this.bot.on('deleteUserData', function(message) {
      for (i = 0; i < this.observers.typing.length; i++) {
        this.observers.deleteUserData[i](message);
      }
    }.bind(this));
    this.bot.on('message', function(message) {
      for (i = 0; i < this.observers.typing.length; i++) {
        this.observers.message[i](message);
      }
    }.bind(this));
    this.bot.on('ping', function(message) {
      for (i = 0; i < this.observers.typing.length; i++) {
        this.observers.ping[i](message);
      }
    }.bind(this));
    this.bot.on('typing', function(message) {
      for (i = 0; i < this.observers.typing.length; i++) {
        this.observers.typing[i](message);
      }
    }.bind(this));
  }

  /**
   * If a dialog class is provided, instantiate the dialogs.
   *
   * @param { Object } opts Options instance.
   * @param { Function } cb Callback function.
   */
  createDialogClass(opts, cb) {
    winston.log('info', 'Creating Dialogs');
    const DialogClass = opts.dialogClass;
    if (DialogClass) {
      winston.log('warn', 'Creating Dialog class instance.');
      this.dialogs = new DialogClass(this);
    } else {
      winston.log('warn', 'Dialog class not defined!');
    }
    cb();
  }

  /**
   * Configure handlebars.
   *
   * @param i18nFolder { String } the folder where i18n files are
   * @param locales { Array } the handled locales.
   */
  configureLocalization({i18nFolder, locales = ['en']}) {
    winston.info('Configure localization');
    const options = {
      debug: false,
      lng: locales[0],
      fallbackLng: locales,
      backend: {
        loadPath: path.join(process.cwd(), i18nFolder, '{{lng}}.json')
      }
    };

    winston.debug('Localization options', {options});
    i18next.use(Backend).init(options);

    this.domain.setRootVariable('locale', options.lng);
    winston.verbose('Default locale set as root variable', {locale: options.lng});

    winston.debug('Registering i18n helper');
    Handlebars.registerHelper('i18n', (key, {hash}) => {
      const options = Object.assign({}, hash, {lng: hash.locale});
      const result = i18next.t(key, options);
      winston.debug('Template i18n helper', {result, key, options});
      return new Handlebars.SafeString(result);
    });
  }

  /**
   * Add an observer for the Conversation Update event.
   *
   * @param { Function } cb Callback Function.
   */
  observeConversationUpdate(cb) {
    this.observers.conversationUpdate.push(cb);
  }

  /**
   * Add an observer for the Contact Relation Update event.
   *
   * @param { Function } cb Callback Function.
   */
  observeContactRelationUpdate(cb) {
    this.observers.contactRelationUpdate.push(cb);
  }

  /**
   * Add an observer for the Delete User Data event.
   *
   * @param { Function } cb Callback function.
   */
  observeDeleteUserData(cb) {
    this.observers.deleteUserData.push(cb);
  }

  /**
   * Add an observer for the Message event.
   *
   * @param { Function } cb Callback function.
   */
  observeMessage(cb) {
    this.observers.message.push(cb);
  }

  /**
   * Add an observer for the Ping event.
   *
   * @param { Function } cb Callback function.
   */
  observePing(cb) {
    this.observers.ping.push(cb);
  }

  /**
   * Add an observer for the Typing event.
   *
   * @param { Function } cb Callback function.
   */
  observeTyping(cb) {
    this.observers.typing.push(cb);
  }

  /**
   * Add an observer for the Person Enter Group event.
   *
   * @param { Function } cb Callback function.
   */
  observePersonEnterGroup(cb) {
    this.observers.personEnterGroup.push(cb);
  }

  /**
   * Add an observer for the Person Leave Group event.
   *
   * @param { Function } cb Callback function.
   */
  observePersonLeaveGroup(cb) {
    this.observers.personLeaveGroup.push(cb);
  }

  /**
   * Creates the domain of the bot.
   *
   * @param { Object } opts Options instance.
   */
  createDomain(opts) {
    winston.log('info', 'Creating domain');
    this.domain = new BotDomain(this.persistance);
  }

  /**
   * Creates the render factory.
   *
   * @param { Object } opts Options instance.
   */
  createRenderFactory(opts) {
    winston.log('info', 'Creating Render Factory');
    this.renderFactory = new BotRenderFactory(this);
  }

  /**
   * Loads the transactions from the i18n jsons and create a map of
   * transactions in the domain that will be automatically resolved
   * based on the locale of the user.
   *
   * @param { Object } opts Options instance.
   * @param { Function } cb Callback Function.
   */
  createTranslations(opts, cb) {
    winston.log('info', 'Creating i18n layer');
    if (opts.i18nFolder) {
      glob(opts.i18nFolder + '/*.json', {}, function(er, files) {
        if (er) {
          winston.log('error', er);
          return;
        }
        for (let i = 0; i < files.length; i++) {
          this.domain.loadTranslations(files[i]);
        }
        winston.log('info', JSON.stringify(this.domain.i18n));
        cb();
      }.bind(this));
    } else {
      cb();
    }
  }

  /**
   * Load the cards from the card folder defined by the configuration.
   * Creates a map with the cards so they can be accessed by name.
   * The name can be also be a "deep name" ( example: rootname.card1 )
   *
   * @param { Object } opts Options instance.
   * @param { Function } cb Callback function.
   */
  createCards(opts, cb) {
    winston.log('info', 'Loading cards from folder');
    if (opts.cardFolder) {
      glob(opts.cardFolder + '/*.json', {}, function(er, files) {
        if (er) {
          winston.log('error', er);
          return;
        }
        for (let i = 0; i < files.length; i++) {
          const name = path.basename(files[i], '.json').toLowerCase();
          winston.info('info', 'adding card ' + name);
          this.cards[name] = JSON.parse(fs.readFileSync(files[i]));
        }
        cb();
      }.bind(this));
    } else {
      winston.log('info', 'No card folder defined.');
      cb();
    }
  }

  /**
   * Load the actions from the action folder defined by the configuration.
   * Creates a map with the actions so they can be accesed by name.
   *
   * @param { Object } opts Options instance.
   * @param { Function } cb Callback function.
   */
  createActions(opts, cb) {
    winston.log('info', 'Loading actions from folder');
    if (opts.actionFolder) {
      glob(opts.actionFolder + '/*.json', {}, function(er, files) {
        // TODO: Define how to read the actions
        cb();
      });
    } else {
      winston.log('info', 'No action folder defined.');
      cb();
    }
  }

  /**
   * Loads the dialogs from the dialog folder defined by the configuration.
   * Build the dialogs automatically into the bot.
   *
   * @param { Object } opts Options instance.
   * @param { Function } cb Callback function.
   */
  createDialogs(opts, cb) {
    winston.log('info', 'Loading dialogs from folder');
    if (opts.dialogFolder) {
      glob(opts.dialogFolder + '/*.json', {}, function(er, files) {
        if (er) {
          winston.log('error', er);
          return;
        }
        for (let i = 0; i < files.length; i++) {
          const name = path.basename(files[i], '.json').toLowerCase();
          winston.info('info', 'adding card ' + name);
          const dialogJson = JSON.parse(fs.readFileSync(files[i]));
          let dialogpath = dialogJson.path || '/' + name;
          if (dialogpath === 'root' || dialogpath === '/root') {
            dialogpath = '/';
          }
          const mustRepeat = dialogJson.repeat || false;
          this.buildDialog(dialogpath, dialogJson.actions, mustRepeat);
        }
        cb();
      }.bind(this));
    } else {
      winston.log('info', 'No dialog folder defined.');
      cb();
    }
  }

  /**
   * Render a card using the render factory.
   *
   * @param { Object } session Chat sesstion.
   * @param { Object } card Card to be rendered.
   * @param { Function } cb Callback function.
   */
  renderCard(session, card, cb) {
    winston.log('debug', 'Rendering a card');
    const channel = session.message.source;
    const renderer = this.renderFactory.getRenderer(card.type, channel);
    if (renderer === undefined) {
      winston.log('Error', 'No renderer found for ' + card.type);
      return cb('No renderer found for ' + card.type);
    }
    renderer.render(session, card, cb);
  }

  /**
   * Sends a list of cards to the session chat.
   *
   * @param { Object } session Chat session.
   * @param { Array[] } cards Array of cards.
   * @param { Function } cb Callback function.
   */
  send(session, cards, cb) {
    winston.log('debug', 'Sending cards');
    if (this.opts && this.opts.autoTyping) {
      winston.log('debug', 'Sending typing');
      session.sendTyping();
    }
    if (!_.isArray(cards)) {
      cards = [cards];
    }
    async.mapSeries(cards, this.renderCard.bind(this, session), cb);
  }

  /**
   * Gets the selected choice from the chat session, after a choice prompt
   * to the user, from the arguments.
   *
   * @param { Object } session Chat session.
   * @param { Object } args Arguments.
   */
  getSelectedChoice(session, args) {
    winston.log('debug', 'Getting selected choice from dialog.');
    if (!args || !args.response || !args.response.entity) {
      return undefined;
    }
    const options = session.dialogData.lastChoice.options;
    const entity = args.response.entity.toLowerCase();
    for (let i = 0; i < options.length; i++) {
      if (entity === options[i].text.toLowerCase()) {
        return options[i].tag;
      }
    }
    return null;
  }

  /**
   * Gets the prompt response and process the storage into the persistance
   * engine, using the domain.
   *
   * @param { Object } session Chat session.
   * @param { Object } args Arguments.
   * @param { Function } cb Callback function.
   */
  getPromptResponse(session, args, cb) {
    winston.log('debug', 'Getting Prompt response.');
    const lastPrompt = session.dialogData.lastPrompt;
    winston.log('debug', 'Prompt Data:');
    winston.log('debug', lastPrompt);
    const strResponse = JSON.stringify(args.response);
    winston.log('debug', 'Prompt Response:');
    winston.log('debug', strResponse);
    if (lastPrompt.name) {
      if (lastPrompt.scope === 'user') {
        this.domain.setUserVariable(session.message.address.user.id,
          lastPrompt.name, strResponse, function(error, data) {
            return cb(error, args.response);
          });
      } else if (lastPrompt.scope === 'channel') {
        this.domain.setChannelVariable(session.message.address.user.id,
          lastPrompt.name, strResponse, function(error, data) {
            return cb(error, args.response);
          });
      } else if (lastPrompt.scope === 'root') {
        this.domain.setRootVariable(lastPrompt.name, strResponse,
          function(error, data) {
            return cb(error, args.response);
          });
      } else if (lastPrompt.scope === 'dialog') {
        session.dialogData[lastPrompt.name] = strResponse;
        return cb(null, args.response);
      } else {
        return cb(null, args.response);
      }
    } else {
      return cb(null, args.response);
    }
  }

  /**
   * Gets the choice response and process the storage into the persistance
   * engine, using the domain.
   *
   * @param { Object } session Chat session.
   * @param { Object } args Arguments.
   * @param { Function } cb Callback function.
   */
  getChoiceResponse(session, args, cb) {
    winston.log('debug', 'Getting Choice response.');
    const lastPrompt = session.dialogData.lastPrompt;
    winston.log('debug', 'Prompt Data:');
    winston.log('debug', lastPrompt);
    const tag = this.getSelectedChoice(session, args);
    winston.log('debug', 'Prompt Tag:');
    winston.log('debug', tag);
    if (lastPrompt.name) {
      if (lastPrompt.scope === 'user') {
        this.domain.setUserVariable(session.message.address.user.id,
          lastPrompt.name, tag, function(error, data) {
            return cb(error, tag);
          });
      } else if (lastPrompt.scope === 'channel') {
        this.domain.setChannelVariable(session.message.address.user.id,
          lastPrompt.name, tag, function(error, data) {
            return cb(error, tag);
          });
      } else if (lastPrompt.scope === 'root') {
        this.domain.setRootVariable(lastPrompt.name, tag,
          function(error, data) {
            return cb(error, tag);
          });
      } else if (lastPrompt.scope === 'dialog') {
        session.dialogData[lastPrompt.name] = tag;
        return cb(null, tag);
      } else {
        return cb(null, tag);
      }
    } else {
      return cb(null, tag);
    }
  }

  /**
   * Adds a dialog to the bot.
   *
   * @param { String } path Path of the dialog.
   * @param { Function } action Action function to be executed when the dialog
   *    is triggered.
   */
  addDialog(path, action) {
    winston.log('debug', 'Adding dialog: ' + path);
    return this.bot.dialog(path, action);
  }

  /**
   * Executes the action of start a different dialog. This is an action trigger,
   * so when the user enters the dialog name, the dialog with identifier id
   * is launched.
   *
   * @param { String } name Dialog name. This text, entered by the user, is the
   *                        trigger that executes the new dialog.
   * @param { String } id Dialog identifier. Remember to put the slash
   *                      (/dialog).
   * @param { Object } options Dialog action parameters. The common use is to
   *                        add the matches
   */
  beginDialogAction(name, id, options) {
    winston.log('debug', 'Begin dialog action: ' + name);
    return this.bot.beginDialogAction(name, id, options);
  }

  /**
   * Given a path of the name of a card, retrieves it and return it.
   *
   * @param { String } path Path of the name of the card.
   * @returns { Object } Bot Card instance.
   */
  getCard(path) {
    return _.get(this.cards, path);
  }

  /**
   * Given a string representing a dialog action set, return the actions
   * tokenized.
   *
   * @param { String } s String representing a dialog action set.
   * @returns { Array } Array of tokens.
   */
  parseDialogAction(s) {
    return s.split(',').map(token => token.trim());
  }

  /**
   * Given an array representing a dialog action set, build the actions
   * object and put them into an array as a result.
   *
   * @param { Array } actions Array of actions to be built.
   * @returns { Array } Array of actions built.
   */
  getDialogActions(actions) {
    var result = [];
    if (!_.isArray) {
      actions = [actions];
    }
    for (var i = 0; i < actions.length; i++) {
      var action = actions[i];
      if (_.isString(action)) {
        var tokens = this.parseDialogAction(action);
        for (var j = 0; j < tokens.length; j++) {
          var token = tokens[j];
          if (token && token.length > 0) {
            if (token[0] === '/') {
              result.push(BaseActions.beginDialog(token));
            } else if (token[0] === '*') {
              result.push(BaseActions.endDialog());
            } else if (token[0] === '(') {
              // TODO: is a list
            } else if (token[0] === '[') {
              // TODO: is a carousel
            } else {
              result.push(this.getCard(token));
            }
          }
        }
      } else if (_.isObject(action)) {
        result.push(action);
      } else if (_.isArray(action)) {
        var delta = this.getDialogActions(action);
        for (var j = 0; j < delta.length; j++) {
          result.push(delta[j]);
        }
      }
    }
    return result;
  }

  /**
   * Build a dialog. From the steps of the dialog, this iterate a build the
   * dialog actions.
   *
   * @param { String } path Path of the dialogs
   * @param { Array } actions Array with the actions. The actions can be cards,
   *      common actions or directly a function.
   * @param { Boolean } repeat Indicates if the dialog repeats in a loop or is
   *          autoconclusive.
   */
  buildDialog(path, actions, repeat) {
    winston.log('debug', 'Building dialog: ' + path);
    actions = this.getDialogActions(actions);
    var arr = [];
    for (var i = 0; i < actions.length; i++) {
      var action = actions[i];
      if (_.isString(action)) {
        action = this.getCard(action);
      }
      if (_.isFunction(action)) {
        arr.push(action);
      } else {
        if (action.type !== 'action') {
          arr.push(BaseActions.sendAction.bind(this, action));
          if (action.type === 'choice') {
            if (action.isMenu === true) {
              arr.push(BaseActions.reactMenuAction.bind(this));
            } else {
              arr.push(BaseActions.reactChoiceAction.bind(this));
            }
          } else if (action.type === 'prompt') {
            if (action.subtype === 'attachment') {
              arr.push(BaseActions.reactPromptAttachmentAction.bind(this));
            } else {
              arr.push(BaseActions.reactPromptAction.bind(this));
            }
          }
        } else {
          if (action.subtype === 'begin') {
            arr.push(BaseActions.beginDialogAction.bind(this, action.path));
          } else if (action.subtype === 'end') {
            arr.push(BaseActions.endDialogAction.bind(this));
          } else if (action.subtype === 'sendList') {
            arr.push(BaseActions.sendListAction.bind(this, action.cards));
          } else if (action.subtype === 'sendCarousel') {
            arr.push(BaseActions.sendCarouselAction.bind(this, action.cards));
          }
        }
      }
    }
    if (repeat) {
      arr.push(BaseActions.replaceDialogAction.bind(this, path));
    } else {
      arr.push(BaseActions.endDialogAction.bind(this));
    }
    this.addDialog(path, arr);
  }
}

BotCore.BaseActions = BaseActions;

export default BotCore;
