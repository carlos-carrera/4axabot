# AMF Bot Framework

## Installation

This is a npm package so the recommendation is to deploy it into a private npm artifactory, and include it into your project npm packages.

## How to use

Instantiate a new BotCore. 
The BotCore takes an options object as parameter. The options object can contain several properties:
  * botAppId : Microsoft Bot APP ID. If not provided, it will be taken from the environment variable BOT_APP_ID.
  * botAppPassword : Microsoft Bot APP PASSWORD. If not provided, it will be taken from the environment variable BOT_APP_PASSWORD. 
  * useLoopback : If true, then it will create a loopback persistance for the bot, based on the loopback application passed as parameter as app.
  * app : Loopback application.
  * persistance : If no useLoopback is defined, then you can provide your own persistance instance in this property. If this persistance is not defined neither useLoopback, then a memory persistance will be instantiated.
  * dialogClass : If provided, it must be an object class that the bot will instantiate passing itself as parameter.  

After instantiating the bot, create a route redirected to the listen of the bot connector. This route can be created using express, restify, hapi... In the example we are using express through loopback application. 

```javascript
    app.bot = new BotCore({ useLoopback: true, app: app, dialogClass: BotDialogs });
    app.post('/api/messages', app.bot.connector.listen());
```

## Defining your bot

In order to define your bot you'll need to understand 3 different artifacts.
* Cards: A card is any item that the bot can show to the user. The cards are separated from the other layers in order to have multilanguage and a template engine, so the cards can user variables that can be replaced on the fly by variable values.
* Actions: An action is any method that can be executed. By default, several useful actions are already defined in the bot core, but the developer is free to declare its own actions, mainly for integration with other systems.
* Dialogs: This is the core of the bot, and represents the state machine of the dialogs of the bot. This is the place to develop your interactions.

### Cards

There are several type of cards that you can use in your bots. The default cards that you can use are:
* Text: This is the basic card, used to send a text to the user.

```javascript
    saluteText: _.clone({
        type: 'text',
        text: 'Hello {{ message.address.user.name }}'
    })
```

* Hero Card: A hero card is a card where an image is the focus of the card, and can have title, subtitle, text, buttons and an action executed when tapped:

```javascript
    areyouokCard: _.clone({
        type: 'hero',
        title: 'Are You Ok?',
        text: 'Are You Ok? is an innovative app for seniors and their families',
        image: '{{{ root.url }}}/images/areyouok.png',
        tap: {
            type: 'openUrl',
                url: '{{{ root.url }}}/images/areyouok.png'
            },
        buttons: [
            { 
                type: 'openUrl',
                url: 'https://play.google.com/store/apps/details?id=com.axa.wellbe.lu',
                title: 'Store'
            }
        ]
    })
```

* Thumbnail Card: A thumbnail card is like a hero card, but the image is smaller and at the right of the text, giving more importance to the text content than to the image itself

```javascript
    areyouokCard: _.clone({
        type: 'thumbnail',
        title: 'Are You Ok?',
        text: 'Are You Ok? is an innovative app for seniors and their families',
        image: '{{{ root.url }}}/images/areyouok.png',
        tap: {
            type: 'openUrl',
                url: '{{{ root.url }}}/images/areyouok.png'
            },
        buttons: [
            { 
                type: 'openUrl',
                url: 'https://play.google.com/store/apps/details?id=com.axa.wellbe.lu',
                title: 'Store'
            }
        ]
    })
```

* List card: A list card represents an array of cards shown in vertical mode to the user. You can define them as cards, but also you can define them in a more dynamic way using a default action. This second method is recomended in order to build dinamycally the list of items

```javascript
    Act.sendList([cards.wellbeCard, cards.areyouokCard])
```

* Carousel card: A carousel card represents an array of cards shown as a carousel that can be horizontal scrolled. You can define them as cards, but also you can define them in a more dynamic way using a default action. This second method is recomended in order to build dinamycally the list of items
        
```javascript
    Act.sendCarousel([cards.wellbeCard, cards.areyouokCard])
```
* Image card: An image card is just this, an image sent to the user.
        
```javascript
    uipictureCard: _.clone({
        type: 'image',
        images: [
            {
                contentType: 'image/jpg',
                contentUrl: '{{{ root.url }}}/images/bb8.jpg' 
            }
        ] 
    })
```
* Prompt card: This card sends a text to the user and waits for a response. The prompt cards doesn't continue to the next in the waterfall until the reception of the input.
        There are several type of prompts: text, number, confirm (yes/no), time and attachment. There is another type of prompt that is the choice, but it has it's own type of card.
        The prompts can save the response of the user into variables. For doing this you need to tell the scope (root, user, channel or dialog) and the variable name.

```javascript
    promptTextText: _.clone({
        type: 'prompt',
        subtype: 'text',
        text: 'Enter some text and I will say it back',
        scope: 'user', 
        name: 'promptText'
    })
```

* Choice card: This card represents a choice shown to the user. The choice can be shown in three ways: button, list and inline. 
        It's a prompt, so the response can be stored into a variable in the same way as the usual prompts.
        The options of the choice have a tag and a text. The text is shown to the user, but when the user does the selection, the tag is returned.

```javascript
    promptListStyle: _.clone({
        type: 'choice',
        subtype: 'button',
        text: 'Choose a list style',
        options: [
            { tag: 'auto', text: 'Automatic'},
            { tag: 'inline', text: 'Inline'},
            { tag: 'list', text: 'List'},
            { tag: 'button', text: 'Buttons'},
            { tag: 'none', text: 'None'}
        ],
        scope: 'dialog',
        name: 'listStyle' 
    })
```

        There is an special use of the choices, that is the menu. This can be specified by using the field "isMenu" setted to true. 
        When a choice car is a menu, it means that the tag represents the name of a dialog that must be started if this option is selected. When the tag is 'quit' the current dialog is ended.
```javascript 
    menuText: _.clone({
        type: 'choice',
        subtype: 'button',
        text: 'What demo would you like to run?',
        isMenu: true,
        options: [
            { tag: 'uielements', text: 'UI Elements'},
            { tag: 'integrations', text: 'Integrations'},
            { tag: 'natural', text: 'Natural Language'},
            { tag: 'multirisk', text: 'Multi Risk'},
            { tag: 'quit', text: 'Quit'}
        ] 
    })
```

### Actions        

The actions represents any method that you want to execute as an step in your dialog waterfall. Usually, an action is a calculation or integration with another system.
To write your own actions, you have to take into account that your method at least will receive 3 parameters:
* session: The Microsoft Bot Chat session. 
* args: The arguments, usually the parameters passed from the previous step, or the user response input.
* next: The callback function to continue to the next step of the waterfall. If your action is a prompt to the user, don't call next, because you don't need to continue to the next step until the user response. 
    
```javascript
    showBmi: function(session, args, next) {
        var height = session.dialogData.height/100;
        var weight = session.dialogData.weight;
        var bmi = weight/(height*height);         
        session.send('Your calculated BMI is: '+bmi.toFixed(0));
        next();       
    }
```
 
### Dialogs

The core of your bot! The main concept is that your dialog object must have a constructor that recives the bot as parameter, and then the instance of the dialogs must initialize the bot adding things to the bot.

The usual constructor of your bot will be something like that:

```javascript
    var BotDialogs = function(bot) {
        this.bot = bot;
        this.initialize();
    };
```

In the initialization there are several things that you can do. Usually, you'll define your dialogs using the buildDialog method, that receives the path of the dialog (beginning by the slash) and the array of things to be executed.
The things that you can pass are:
* cards: you can use directly cards, that will be replaced on the fly by the actions needed to show the card. In the case of a prompt, it will be replaced by the action of sending the prompt and the action to react to the user input.
* basic actions: actions already defined in the bot. You can access these actions in the property BaseActions of the BotCore class. The actions will be binded to the bot instance automatically.
        ```javascript
            var Act = require('bot-core').BaseActions;
        ``` 
* own actions: actions defined by the developer. In this case, you must bind the actions to the "this" that you want for the action, and the parameters that you want to receive before the session.
        ```javascript
            BotActions.getWeather.bind(bot)
        ```

Usually you will have dialogs defined like this:

```javascript
    bot.buildDialog('/', [
        cards.saluteCard,
        cards.saluteText,
        Act.beginDialog('/help'),
        Act.beginDialog('/menu'),
        cards.goodbyeText
    ]);
```

## Customizing your bot for other channels

The bot renders the card using a factory that returns the correct renderer for each situation.
The render factory works accepting two parameter: the channel and the card type. Always search the custom defined cards for the channel, if not found then returns the default card renderer.

The render factory can be accessed through the property "rendererFactory" of the bot. 
In the renderer you can add renderers for a defined channel:
```javascript
    bot.renderFactory.addRendererByChannel('hero', 'mobile', renderer);
```
Or you can add renderers by default for a card type:
```javascript
    bot.renderFactory.addRendererByType('hero', renderer);
```

This way, you can add also your own card types adding the renderer for the cards.

The initialization of the renderer already adds the renderers by default for the usual card types:

```javascript
BotRenderFactory.prototype.addDefaultRenderers = function() {
    this.addRendererByType('text', new TextRenderer(this.bot));
    this.addRendererByType('hero', new HeroRenderer(this.bot));
    this.addRendererByType('thumbnail', new ThumbnailRenderer(this.bot));
    this.addRendererByType('choice', new ChoiceRenderer(this.bot));
    this.addRendererByType('carousel', new CarouselRenderer(this.bot));
    this.addRendererByType('image', new ImageRenderer(this.bot));
    this.addRendererByType('list', new ListRenderer(this.bot));
    this.addRendererByType('prompt', new PromptRenderer(this.bot));
};
```

## Connectors

You can use custom connectors to use the different messaging channels without using the Microsoft account.
At this point, three connectors are developed:
- RestConnector: the one to publish a REST service
- FacebookConnector: to communicate with Facebook
- MultiConnector: a connector that allows to add other connectors so you can work with several channels at the same time.

Example of use of the three at the same time:

```javascript
    var facebookconnector = new FacebookConnector({ 
    	verifyToken: '<FACEBOOK_WEBHOOK_VERIFY_TOKEN>',
    	accessToken: '<FACEBOOK_ACCESS_TOKEN>',
		appSecret: '<FACEBOOK_APP_SECRET>'
    });
	var restconnector = new RestConnector({});
	var connector = new MultiConnector({});
	connector.addConnector('emulator', restconnector);
	connector.addConnector('facebook', facebookconnector);
    bot = new builder.UniversalBot(connector);
```